<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>YuZai | YuZai</title><meta name="author" content="雨崽"><meta name="copyright" content="雨崽"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Transformer模型详解一、Transformer由来Transformer是一种基于**注意力机制**（attention mechanism）的深度学习模型架构，最初由Vaswani等人在2017年提出。Transformer主要用于自然语言处理（NLP）任务，特别是用于机器翻译。 传统的序列模型（比如循环神经网络和长短期记忆网络）在处理长序列时存在一些问题，比如梯度消失和梯度爆炸等。而">
<meta property="og:type" content="article">
<meta property="og:title" content="YuZai">
<meta property="og:url" content="http://example.com/2024/02/22/Transformer%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="YuZai">
<meta property="og:description" content="Transformer模型详解一、Transformer由来Transformer是一种基于**注意力机制**（attention mechanism）的深度学习模型架构，最初由Vaswani等人在2017年提出。Transformer主要用于自然语言处理（NLP）任务，特别是用于机器翻译。 传统的序列模型（比如循环神经网络和长短期记忆网络）在处理长序列时存在一些问题，比如梯度消失和梯度爆炸等。而">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.jpg">
<meta property="article:published_time" content="2024-02-22T09:22:19.782Z">
<meta property="article:modified_time" content="2024-03-06T11:50:41.378Z">
<meta property="article:author" content="雨崽">
<meta property="article:tag" content="人工智能">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.jpg"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2024/02/22/Transformer%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'YuZai',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-06 19:50:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 藏宝库</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="YuZai"><span class="site-name">YuZai</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 藏宝库</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-22T09:22:19.782Z" title="发表于 2024-02-22 17:22:19">2024-02-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-06T11:50:41.378Z" title="更新于 2024-03-06 19:50:41">2024-03-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Transformer模型详解"><a href="#Transformer模型详解" class="headerlink" title="Transformer模型详解"></a>Transformer模型详解</h1><h2 id="一、Transformer由来"><a href="#一、Transformer由来" class="headerlink" title="一、Transformer由来"></a>一、Transformer由来</h2><p>Transformer是一种基于**<u>注意力机制</u>**（attention mechanism）的深度学习模型架构，最初由Vaswani等人在2017年提出。Transformer主要用于自然语言处理（NLP）任务，特别是用于机器翻译。</p>
<p>传统的序列模型（比如循环神经网络和长短期记忆网络）在处理长序列时存在一些问题，比如梯度消失和梯度爆炸等。而Transformer模型通过引入注意力机制，可以更好地处理长距离依赖关系，而且能够并行计算，提高了训练效率。</p>
<p>Transformer模型的核心组件包括**<u>自注意力机制（self-attention mechanism）和全连接前馈网络（feed-forward neural networks）。</u>**自注意力机制使得模型能够在输入序列中各个位置之间进行直接交互，从而更好地捕捉序列中的依赖关系。</p>
<p>Transformer模型的一个重要应用是Google提出的BERT（Bidirectional Encoder Representations from Transformers），它是一种预训练语言模型，可以用于各种NLP任务的微调，包括文本分类、命名实体识别、语义理解等。</p>
<p>原论文地址（感兴趣的可以看一看）：<a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1706.03762">https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1706.03762</a></p>
<h2 id="二、Transformer的网络架构"><a href="#二、Transformer的网络架构" class="headerlink" title="二、Transformer的网络架构"></a>二、Transformer的网络架构</h2><h4 id="1、transformer整体结构"><a href="#1、transformer整体结构" class="headerlink" title="1、transformer整体结构"></a>1、transformer整体结构</h4><p>先让我们看看Transformer 的整体结构，下图是 Transformer 用于中英文翻译的整体结构</p>
<p><img src="https://pic4.zhimg.com/80/v2-4544255f3f24b7af1e520684ae38403f_720w.webp" alt="img"></p>
<p>可以发现Transformer的结构和Attention模型一样，Transformer模型中也采用了 encoer-decoder 架构。但其结构相比于Attention更加复杂，论文中encoder层由6个encoder堆叠在一起，decoder层也一样。</p>
<p>Encoder-decoder是之前机器翻译任务中最常用的架构，即将整个翻译过程拆分为encoder和decoder两部分。其中encoder将输入序列（其中每一个元素的表示为 (<img src="C:\Users\yangtianyu\AppData\Roaming\Typora\typora-user-images\image-20240222162651942.png" alt="image-20240222162651942">）转换成一个向量 <img src="C:\Users\yangtianyu\AppData\Roaming\Typora\typora-user-images\image-20240222162708775.png" alt="image-20240222162708775">，之后decoder再以此向量为输入生成输出序列 <img src="C:\Users\yangtianyu\AppData\Roaming\Typora\typora-user-images\image-20240222162720876.png" alt="image-20240222162720876">（每个时刻生成其中的一个元素）。在每一步模型都是自回归的（auto-regressive)，即在生成下一个结果时将之前已经生成的元素也作为额外的输入考虑进来。</p>
<p>每一个encoder和decoder的内部结构如下图：</p>
<p><img src="https://gitee.com/kkweishe/images/raw/master/ML/2019-9-25_23-25-14.png" alt="img"></p>
<ul>
<li><u><strong>encoder，包含两层，一个self-attention层和一个前馈神经网络，self-attention能帮助当前节点不仅仅只关注当前的词，从而能获取到上下文的语义。</strong></u></li>
<li><u><strong>decoder也包含encoder提到的两层网络，但是在这两层中间还有一层attention层，帮助当前节点获取到当前需要关注的重点内容。</strong></u></li>
</ul>
<h4 id="2、transformer的工作流程"><a href="#2、transformer的工作流程" class="headerlink" title="2、transformer的工作流程"></a>2、transformer的工作流程</h4><p>下面让我们来看看transformer的工作流程：</p>
<p>（1）获取输入句子的每一个单词的表示向量 <strong>X</strong>，<strong>X</strong>由单词的 Embedding（Embedding就是从原始数据提取出来的Feature） 和单词位置的 Embedding 相加得到。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7dd39c44b0ae45d31a3ae7f39d3f883f_720w.webp" alt="img"></p>
<p>（2）将得到的单词表示向量矩阵 (如上图所示，每一行是一个单词的表示 <strong>x</strong>) 传入 Encoder 中，经过 6 个 Encoder block 后可以得到句子所有单词的编码信息矩阵 <strong>C</strong>，如下图。单词向量矩阵用 <img src="C:\Users\yangtianyu\AppData\Roaming\Typora\typora-user-images\image-20240222155404312.png" alt="image-20240222155404312">表示， n 是句子中单词个数，d 是表示向量的维度 (论文中 d&#x3D;512)。每一个 Encoder block 输出的矩阵维度与输入完全一致。</p>
<p><img src="https://pic3.zhimg.com/80/v2-45db05405cb96248aff98ee07a565baa_720w.webp" alt="img"></p>
<p>（3）将 Encoder 输出的编码信息矩阵 <strong>C</strong>传递到 Decoder 中，Decoder 依次会根据当前翻译过的单词 1~ i 翻译下一个单词 i+1，如下图所示。在使用的过程中，翻译到单词 i+1 的时候需要通过 <strong>Mask (掩盖)</strong> 操作遮盖住 i+1 之后的单词。<!--Mask操作后面会解释--></p>
<p>下图 Decoder 接收了 Encoder 的编码矩阵 <strong>C</strong>，然后首先输入一个翻译开始符 “<Begin>“，预测第一个单词 “I”；然后输入翻译开始符 “<Begin>“ 和单词 “I”，预测单词 “have”，以此类推。这是 Transformer 使用时候的大致流程，接下来是里面各个部分的细节。</p>
<p><img src="https://pic2.zhimg.com/80/v2-5367bd47a2319397317562c0da77e455_720w.webp" alt="img"></p>
<h4 id="3、transformer各部分详解"><a href="#3、transformer各部分详解" class="headerlink" title="3、transformer各部分详解"></a>3、transformer各部分详解</h4><h5 id="（1）单词-Embedding"><a href="#（1）单词-Embedding" class="headerlink" title="（1）单词 Embedding"></a>（1）单词 Embedding</h5><p>单词 Embedding 是自然语言处理（NLP）中的一个重要概念。它指的是将单词或短语映射到连续向量空间中的过程。在这个连续向量空间中，单词的语义信息可以被更好地捕捉和表示。单词 Embedding 在许多 NLP 任务中都是至关重要的，例如情感分析、命名实体识别、语义相似度计算等。</p>
<p>单词 Embedding 的获得通常通过以下几种方法：</p>
<ol>
<li><strong>预训练的词嵌入模型</strong>：这是最常见的方法之一。预训练的词嵌入模型，如 Word2Vec、GloVe、FastText 和 BERT 等，通过大规模的文本语料库学习单词的向量表示。这些模型在大量的语料库上训练得到的单词 Embedding 可以捕捉到单词之间的语义关系。</li>
<li><strong>训练自定义的词嵌入模型</strong>：如果你有足够的数据和计算资源，你也可以训练自己的词嵌入模型。你可以使用诸如 Word2Vec 或 Skip-gram 模型这样的算法，在你自己的数据集上训练单词 Embedding。</li>
<li><strong>使用深度学习模型中的嵌入层</strong>：在进行特定的 NLP 任务时，你可以使用深度学习模型（如循环神经网络、卷积神经网络或 Transformer 模型）的嵌入层来学习单词 Embedding。在这种情况下，模型会自动学习单词的向量表示，并在任务的训练过程中进行优化。</li>
</ol>
<h5 id="（2）位置-Embedding"><a href="#（2）位置-Embedding" class="headerlink" title="（2）位置 Embedding"></a>（2）位置 Embedding</h5><p>Transformer 中除了单词的 Embedding，还需要使用位置 Embedding 表示单词出现在句子中的位置。<strong>因为 Transformer 不采用 RNN 的结构，而是使用全局信息，不能利用单词的顺序信息，而这部分信息对于 NLP 来说非常重要。</strong>所以 Transformer 中使用位置 Embedding 保存单词在序列中的相对或绝对位置。</p>
<p>位置 Embedding 用 <strong>PE</strong>表示，<strong>PE</strong> 的维度与单词 Embedding 是一样的。PE 可以通过训练得到，也可以使用某种公式计算得到。在 Transformer 中采用了后者，计算公式如下：<br>$$<br>\begin{array}{c}<br>P E_{(p o s, 2 i)}&#x3D;\sin \left(p o s &#x2F; 10000^{2 i &#x2F; d}\right) \<br>P E_{(p o s, 2 i+1)}&#x3D;\cos \left(p o s &#x2F; 10000^{2 i &#x2F; d}\right)<br>\end{array}<br>$$<br>其中，**<u>pos 表示单词在句子中的位置，d 表示 PE的维度 (与词 Embedding 一样)，2i 表示偶数的维度，2i+1 表示奇数维度 (即 2i≤d, 2i+1≤d)。</u>**使用这种公式计算 PE 有以下的好处：</p>
<ul>
<li>使 PE 能够适应比训练集里面所有句子更长的句子，假设训练集里面最长的句子是有 20 个单词，突然来了一个长度为 21 的句子，则使用公式计算的方法可以计算出第 21 位的 Embedding。</li>
<li>可以让模型容易地计算出相对位置，对于固定长度的间距 k，<strong>PE(pos+k)</strong> 可以用 <strong>PE(pos)</strong> 计算得到。因为 Sin(A+B) &#x3D; Sin(A)Cos(B) + Cos(A)Sin(B), Cos(A+B) &#x3D; Cos(A)Cos(B) - Sin(A)Sin(B)。</li>
</ul>
<p>将单词的词 Embedding 和位置 Embedding 相加，就可以得到单词的表示向量 <strong>x</strong>，<strong>x</strong> 就是 Transformer 的输入。</p>
<p><img src="C:\Users\yangtianyu\AppData\Roaming\Typora\typora-user-images\image-20240222161844174.png" alt="image-20240222161844174"></p>
<h5 id="（3）Self-Attention（自注意力机制）"><a href="#（3）Self-Attention（自注意力机制）" class="headerlink" title="（3）Self-Attention（自注意力机制）"></a>（3）Self-Attention（自注意力机制）</h5><p>可参考我的上一篇文章<a target="_blank" rel="noopener" href="https://yuzai666.top/2024/02/20/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%EF%BC%88Self-Attention%20Mechanism%EF%BC%89/%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E5%81%9A%E8%BF%87%E5%A4%9A%E8%A7%A3%E9%87%8A%EF%BC%8C%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">https://yuzai666.top/2024/02/20/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%EF%BC%88Self-Attention%20Mechanism%EF%BC%89/，这里不做过多解释，简单介绍</a></p>
<p><img src="https://pic4.zhimg.com/80/v2-f6380627207ff4d1e72addfafeaff0bb_720w.webp" alt="img"></p>
<p>上图是论文中 Transformer 的内部结构图，左侧为 Encoder block，右侧为 Decoder block。红色圈中的部分为 <strong>Multi-Head Attention</strong>，是由多个 <strong>Self-Attention</strong>组成的，可以看到 Encoder block 包含一个 Multi-Head Attention，而 Decoder block 包含两个 Multi-Head Attention (其中有一个用到 Masked)。Multi-Head Attention 上方还包括一个 Add &amp; Norm 层，<u>Add 表示残差连接 (Residual Connection) 用于防止网络退化，Norm 表示 Layer Normalization，用于对每一层的激活值进行归一化。</u></p>
<p>因为 <strong>Self-Attention</strong>是 Transformer 的重点，所以我们重点关注 Multi-Head Attention 以及 Self-Attention</p>
<p>具体的流程大致如下图所示<img src="http://wenqianzhao.cn/img/in-post/ml/transformer/self-attention.png" alt="img"></p>
<p>假设输入序列是Dx*N的矩阵（Dx表示输入向量维度，N表示样本数），那么分别经过Wq、Wk和Wv三个线性变换后，可以得到Q、K、V矩阵（注意这里Q和K的维度要相同，但是并不一定要和V相同）。Q和K可以进一步通过<strong>缩放点积</strong>来进行打分，并经过Softmax归一化得到V矩阵的权重，从而计算得到最终的输出向量序列H：<img src="http://wenqianzhao.cn/img/in-post/ml/transformer/formula1.png" alt="img"></p>
<h5 id="（4）多头注意力Multi-Head-Attention"><a href="#（4）多头注意力Multi-Head-Attention" class="headerlink" title="（4）多头注意力Multi-Head Attention"></a>（4）多头注意力Multi-Head Attention</h5><p>介绍自注意力时我们提到可以通过三个不同的线性变换，得到Q、K、V矩阵。假设我们将这三个线性变换看做是一组，那么我们其实可以多训练几组来增强自注意力模型的学习能力（多组不同的线性变换即所谓的多头），Multi-Head Attention 是由多个 Self-Attention 组合形成的。多头注意力的结构如下所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-b0ea8f5b639786f98330f70405e94a75_720w.webp" alt="img"></p>
<p>假设我们一共应用h组线性变换，那就可以得到h个结果矩阵，将它们拼接起来再做一次线性变换，即可得到最后的结果：</p>
<p><img src="http://wenqianzhao.cn/img/in-post/ml/transformer/formula2.png" alt="img"></p>
<p>在原论文中作者设置为h&#x3D;8，如下图所示<img src="https://pic1.zhimg.com/80/v2-6bdaf739fd6b827b2087b4e151c560f4_720w.webp" alt="img"></p>
<p>得到 8 个输出矩阵 Z1 到 Z8 之后，Multi-Head Attention 将它们拼接在一起 <strong>(Concat)<strong>，然后传入一个</strong>Linear</strong>层，得到 Multi-Head Attention 最终的输出<strong>Z</strong>。</p>
<p><img src="https://pic4.zhimg.com/80/v2-35d78d9aa9150ae4babd0ea6aa68d113_720w.webp" alt="img"></p>
<h5 id="（5）逐位置的前馈神经网络-FFN"><a href="#（5）逐位置的前馈神经网络-FFN" class="headerlink" title="（5）逐位置的前馈神经网络(FFN)"></a>（5）逐位置的前馈神经网络(FFN)</h5><p>逐位置的前馈神经网络（Feedforward Neural Network，FFN）是深度学习中常见的一种神经网络结构，特别在自然语言处理（NLP）中被广泛使用。在NLP中，FFN通常作为注意力机制（Attention Mechanism）中的一个组成部分。</p>
<p>FFN由两个或多个全连接层组成，每个全连接层都在其输入之间执行线性变换，然后应用非线性激活函数。这些全连接层是逐位置（position-wise）的，这意味着每个序列位置（例如单词或词向量序列中的位置）都会经过相同的变换。</p>
<p>在注意力机制中，逐位置的前馈神经网络通常用来对注意力权重进行非线性转换或对特征进行映射。在自注意力机制（Self-Attention）中，FFN通常被放置在每个注意力子层之后。这样的设计有助于捕获序列中每个位置的局部信息，并在不同的位置上执行不同的转换。</p>
<p>通常，FFN的结构如下：</p>
<ol>
<li><u><strong>线性变换层（全连接层）</strong>：这些层执行输入向量和权重矩阵之间的线性变换。</u></li>
<li><u><strong>激活函数</strong>：通常在线性变换之后应用非线性激活函数，例如ReLU（Rectified Linear Unit）。</u></li>
</ol>
<p>FFN的目的是通过对序列中每个位置的信息进行非线性转换，从而增强模型的表征能力。在Transformer模型中，FFN层被放置在每个注意力层的后面，以便对注意力层的输出进行进一步的转换和特征提取。</p>
<p>其实说白了FFN其实就是一个简单的二层网络，其中第一层的激活函数为ReLU。对于输入序列中每个位置上的向量x：<img src="http://wenqianzhao.cn/img/in-post/ml/transformer/ffn.png" alt="img"></p>
<p>需要注意的是：在同一层上（这里指的是Encoder或Decoder内的层），每个位置上的向量x所对应的参数W1、W2、b1、b2都是相同的，但是层与层之间的参数时不同的。FFN的作用应该就是提供更多的非线性和学习能力。</p>
<h5 id="（6）Add-Norm"><a href="#（6）Add-Norm" class="headerlink" title="（6）Add &amp; Norm"></a>（6）Add &amp; Norm</h5><p>Add &amp; Norm 层由 Add 和 Norm 两部分组成，其计算公式如下</p>
<p><img src="https://pic3.zhimg.com/80/v2-a4b35db50f882522ee52f61ddd411a5a_720w.webp" alt="img"></p>
<p>其中 <strong>X</strong>表示 Multi-Head Attention 或者 Feed Forward 的输入，MultiHeadAttention(<strong>X</strong>) 和 FeedForward(<strong>X</strong>) 表示输出 (输出与输入 <strong>X</strong> 维度是一样的，所以可以相加)。</p>
<p><strong>Add</strong>指 <strong>X</strong>+MultiHeadAttention(<strong>X</strong>)，是一种残差连接，通常用于解决多层网络训练的问题，可以让网络只关注当前差异的部分，在 ResNet 中经常用到；</p>
<p><strong>Norm</strong>指 Layer Normalization，通常用于 RNN 结构，Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的，这样可以加快收敛。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4b3dde965124bd00f9893b05ebcaad0f_720w.webp" alt="img"></p>
<h5 id="（7）Encoder组成"><a href="#（7）Encoder组成" class="headerlink" title="（7）Encoder组成"></a>（7）Encoder组成</h5><p>通过上面描述的 Multi-Head Attention, Feed Forward, Add &amp; Norm 就可以构造出一个 Encoder block，Encoder block 接收输入矩阵 <img src="C:\Users\yangtianyu\AppData\Roaming\Typora\typora-user-images\image-20240222164336600.png" alt="image-20240222164336600">，并输出一个矩阵<img src="C:\Users\yangtianyu\AppData\Roaming\Typora\typora-user-images\image-20240222164346556.png" alt="image-20240222164346556">。通过多个 Encoder block 叠加就可以组成 Encoder。</p>
<p>第一个 Encoder block 的输入为句子单词的表示向量矩阵，后续 Encoder block 的输入是前一个 Encoder block 的输出，最后一个 Encoder block 输出的矩阵就是<strong>编码信息矩阵 C</strong>，这一矩阵后续会用到 Decoder 中。<img src="https://pic3.zhimg.com/80/v2-45db05405cb96248aff98ee07a565baa_720w.webp" alt="img"></p>
<h5 id="（8）Decoder-结构"><a href="#（8）Decoder-结构" class="headerlink" title="（8）Decoder 结构"></a>（8）Decoder 结构</h5><p><img src="https://pic3.zhimg.com/80/v2-f5049e8711c3abe8f8938ced9e7fc3da_720w.webp" alt="img"></p>
<p>上图红色部分为 Transformer 的 Decoder block 结构，与 Encoder block 相似，但是存在一些区别：</p>
<ul>
<li><u>包含两个 Multi-Head Attention 层。</u></li>
<li><u>第一个 Multi-Head Attention 层采用了 Masked 操作。</u></li>
</ul>
<p><strong>即翻译完第 i 个单词，才可以翻译第 i+1 个单词。通过 Masked 操作可以防止第 i 个单词知道 i+1 个单词之后的信息。下面以 “我有一只猫” 翻译成 “I have a cat” 为例，了解一下 Masked 操作。如下图所示。首先根据输入 “<Begin>“ 预测出第一个单词为 “I”，然后根据输入 “<Begin> I” 预测下一个单词 “have”。<img src="https://pic1.zhimg.com/80/v2-4616451fe8aa59b2df2ead30fa31dc98_720w.webp" alt="img"></strong></p>
<p><strong>Decoder 可以在训练的过程中使用 Teacher Forcing 并且并行化训练，即将正确的单词序列 (<Begin> I have a cat) 和对应输出 (I have a cat <end>) 传递到 Decoder。那么在预测第 i 个输出时，就要将第 i+1 之后的单词掩盖住，注意 Mask 操作是在 Self-Attention 的 Softmax 之前使用的，下面用 0 1 2 3 4 5 分别表示 “<Begin> I have a cat <end>“。</strong></p>
<p><strong>Mask 操作第一步:是 Decoder 的输入矩阵和 Mask 矩阵，输入矩阵包含 “<Begin> I have a cat” (0, 1, 2, 3, 4) 五个单词的表示向量，Mask 是一个 5×5 的矩阵。在 Mask 可以发现单词 0 只能使用单词 0 的信息，而单词 1 可以使用单词 0, 1 的信息，即只能使用之前的信息。<img src="https://pic1.zhimg.com/80/v2-b26299d383aee0dd42b163e8bda74fc8_720w.webp" alt="img"></strong></p>
<p><strong>第二步：接下来的操作和之前的 Self-Attention 一样，通过输入矩阵X计算得到Q,K,V矩阵。然后计算Q和KT的乘积 QKT。<img src="https://pic4.zhimg.com/80/v2-a63ff9b965595438ed0c0e0547cd3d3b_720w.webp" alt="img"></strong></p>
<p><strong>第三步：</strong>在得到 QKT 之后需要进行 Softmax，计算 attention score，我们在 Softmax 之前需要使用Mask<strong>矩阵遮挡住每一个单词之后的信息，遮挡操作如下：<img src="https://pic2.zhimg.com/80/v2-35d1c8eae955f6f4b6b3605f7ef00ee1_720w.webp" alt="img"></strong></p>
<p><strong>得到 Mask QKT之后在 Mask QKT上进行 Softmax，每一行的和都为 1。但是单词 0 在单词 1, 2, 3, 4 上的 attention score 都为 0。</strong></p>
<p><strong>第四步：使用 Mask QKT与矩阵 V相乘，得到输出 Z，则单词 1 的输出向量 Z1 是只包含单词 1 信息的。<img src="https://pic4.zhimg.com/80/v2-58f916c806a6981e296a7a699151af87_720w.webp" alt="img"></strong></p>
<p><strong>第五步：通过上述步骤就可以得到一个 Mask Self-Attention 的输出矩阵 �� ，然后和 Encoder 类似，通过 Multi-Head Attention 拼接多个输出�� 然后计算得到第一个 Multi-Head Attention 的输出Z，Z与输入X维度一样。</strong></p>
<ul>
<li><u>第二个 Multi-Head Attention 层的<strong>K, V</strong>矩阵使用 Encoder 的<strong>编码信息矩阵C</strong>进行计算，而<strong>Q</strong>使用上一个 Decoder block 的输出计算。</u></li>
</ul>
<p><strong>Decoder block 第二个 Multi-Head Attention 变化不大， 主要的区别在于其中 Self-Attention 的 K, V矩阵不是使用 上一个 Decoder block 的输出计算的，而是使用 Encoder 的编码信息矩阵 C 计算的。</strong></p>
<p><strong>根据 Encoder 的输出 C计算得到 K, V，根据上一个 Decoder block 的输出 Z 计算 Q (如果是第一个 Decoder block 则使用输入矩阵 X 进行计算)，后续的计算方法与之前描述的一致。</strong></p>
<p><strong>这样做的好处是在 Decoder 的时候，每一位单词都可以利用到 Encoder 所有单词的信息 (这些信息无需 Mask)。</strong></p>
<ul>
<li><u>最后有一个 Softmax 层计算下一个翻译单词的概率。</u></li>
</ul>
<p>Decoder block 最后的部分是利用 Softmax 预测下一个单词，在之前的网络层我们可以得到一个最终的输出 Z，因为 Mask 的存在，使得单词 0 的输出 Z0 只包含单词 0 的信息，如下：<img src="https://pic2.zhimg.com/80/v2-335cfa1b345bdd5cf1e212903bb9b185_720w.webp" alt="img"></p>
<p>Softmax 根据输出矩阵的每一行预测下一个单词：</p>
<p><img src="https://pic2.zhimg.com/80/v2-0938aa45a288b5d6bef6487efe53bd9d_720w.webp" alt="img"></p>
<h2 id="三、动态演示图"><a href="#三、动态演示图" class="headerlink" title="三、动态演示图"></a>三、动态演示图</h2><p>编码器通过处理输入序列开启工作。顶端编码器的输出之后会变转化为一个包含向量K（键向量）和V（值向量）的注意力向量集 ，<strong>这是并行化操作</strong>。这些向量将被每个解码器用于自身的“编码-解码注意力层”，而这些层可以帮助解码器关注输入序列哪些位置合适：<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64156846894583861613.gif" alt="img"></p>
<p>在完成编码阶段后，则开始解码阶段。解码阶段的每个步骤都会输出一个输出序列（在这个例子里，是英语翻译的句子）的元素。</p>
<p>接下来的步骤重复了这个过程，直到到达一个特殊的终止符号，它表示transformer的解码器已经完成了它的输出。每个步骤的输出在下一个时间步被提供给底端解码器，并且就像编码器之前做的那样，这些解码器会输出它们的解码结果 。<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64156846899939997439.gif" alt="img"></p>
<p>完成之后如图所示<img src="https://gitee.com/kkweishe/images/raw/master/ML/2019-9-25_23-4-24.png" alt="img"></p>
<h2 id="四、Transformer总结"><a href="#四、Transformer总结" class="headerlink" title="四、Transformer总结"></a>四、Transformer总结</h2><h4 id="1、Transformer相比于RNN-LSTM，有什么优势？为什么？"><a href="#1、Transformer相比于RNN-LSTM，有什么优势？为什么？" class="headerlink" title="1、Transformer相比于RNN&#x2F;LSTM，有什么优势？为什么？"></a>1、Transformer相比于RNN&#x2F;LSTM，有什么优势？为什么？</h4><ol>
<li><p>RNN系列的模型，并行计算能力很差。RNN并行计算的问题就出在这里，因为 T 时刻的计算依赖 T-1 时刻的隐层计算结果，而 T-1 时刻的计算依赖 T-2 时刻的隐层计算结果，如此下去就形成了所谓的序列依赖关系。</p>
</li>
<li><p>Transformer的特征抽取能力比RNN系列的模型要好。</p>
<p>具体实验对比可以参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54743941">放弃幻想，全面拥抱Transformer：自然语言处理三大特征抽取器（CNN&#x2F;RNN&#x2F;TF）比较</a></p>
<p>但是值得注意的是，并不是说Transformer就能够完全替代RNN系列的模型了，任何模型都有其适用范围，同样的，RNN系列模型在很多任务上还是首选，熟悉各种模型的内部原理，知其然且知其所以然，才能遇到新任务时，快速分析这时候该用什么样的模型，该怎么做好。</p>
</li>
</ol>
<h4 id="2、为什么说Transformer可以代替seq2seq？"><a href="#2、为什么说Transformer可以代替seq2seq？" class="headerlink" title="2、为什么说Transformer可以代替seq2seq？"></a>2、为什么说Transformer可以代替seq2seq？</h4><p>​            1、 <strong>seq2seq缺点</strong>：这里用代替这个词略显不妥当，seq2seq虽已老，但始终还是有其用武之地，seq2seq最大的问题在于<strong>将Encoder端的所有信息压缩到一个固定长度的向量中</strong>，并将其作为Decoder端首个隐藏状态的输入，来预测Decoder端第一个单词(token)的隐藏状态。在输入序列比较长的时候，这样做显然会损失Encoder端的很多信息，而且这样一股脑的把该固定向量送入Decoder端，Decoder端不能够关注到其想要关注的信息。</p>
<p>**         2、Transformer优点**：transformer不但对seq2seq模型这两点缺点有了实质性的改进(多头交互式attention模块)，而且还引入了self-attention模块，让源序列和目标序列首先“自关联”起来，这样的话，源序列和目标序列自身的embedding表示所蕴含的信息更加丰富，而且后续的FFN层也增强了模型的表达能力，并且Transformer并行计算的能力是远远超过seq2seq系列的模型，因此我认为这是transformer优于seq2seq模型的地方。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雨崽</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/22/Transformer%E8%AF%A6%E8%A7%A3/">http://example.com/2024/02/22/Transformer%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">YuZai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/02/20/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%EF%BC%88Self-Attention%20Mechanism%EF%BC%89/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雨崽</div><div class="author-info__description">雨崽</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yty666zsy?tab=repositories"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yty666zsy?tab=repositories" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zaiyuzai16@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><b><font color="#e66b6d">双</font> <font color="#e66d98">手</font> <font color="#e66cc6">合</font> <font color="#cc6de6">十</font> <font color="#9770e6">成</font> <font color="#6d93e6">为</font> <font color="#6fcde6">自</font> <font color="#72e6b6">己</font> <font color="#72e689">的</font> <font color="#99e670">神</font>, <font color="#cde670">自</font> <font color="#e6df72">己</font> <font color="#e6c073">所</font> <font color="#e6a271">信</font> <font color="#e6796f">念</font> <font color="#e65454">的</font> <font color="#e63333">即</font> <font color="#e62c2c">是</font> <font color="#e60101">信</font> <font color="#e60101">仰</font></b> <p align="center"><img src="https://haiyong.site/img/img-blog.csdnimg.cn/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="mao"></p> <p align="center">微信号：yty15265803329</p> <p align="center">QQ号：3411994817</p></div></div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Transformer%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">Transformer模型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Transformer%E7%94%B1%E6%9D%A5"><span class="toc-number">1.1.</span> <span class="toc-text">一、Transformer由来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Transformer%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">二、Transformer的网络架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81transformer%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">1、transformer整体结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81transformer%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">2、transformer的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81transformer%E5%90%84%E9%83%A8%E5%88%86%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">3、transformer各部分详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8D%95%E8%AF%8D-Embedding"><span class="toc-number">1.2.0.3.1.</span> <span class="toc-text">（1）单词 Embedding</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BD%8D%E7%BD%AE-Embedding"><span class="toc-number">1.2.0.3.2.</span> <span class="toc-text">（2）位置 Embedding</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Self-Attention%EF%BC%88%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">1.2.0.3.3.</span> <span class="toc-text">（3）Self-Attention（自注意力机制）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%A4%9A%E5%A4%B4%E6%B3%A8%E6%84%8F%E5%8A%9BMulti-Head-Attention"><span class="toc-number">1.2.0.3.4.</span> <span class="toc-text">（4）多头注意力Multi-Head Attention</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E9%80%90%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-FFN"><span class="toc-number">1.2.0.3.5.</span> <span class="toc-text">（5）逐位置的前馈神经网络(FFN)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%886%EF%BC%89Add-Norm"><span class="toc-number">1.2.0.3.6.</span> <span class="toc-text">（6）Add &amp; Norm</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%887%EF%BC%89Encoder%E7%BB%84%E6%88%90"><span class="toc-number">1.2.0.3.7.</span> <span class="toc-text">（7）Encoder组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%888%EF%BC%89Decoder-%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.0.3.8.</span> <span class="toc-text">（8）Decoder 结构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E6%BC%94%E7%A4%BA%E5%9B%BE"><span class="toc-number">1.3.</span> <span class="toc-text">三、动态演示图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Transformer%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">四、Transformer总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Transformer%E7%9B%B8%E6%AF%94%E4%BA%8ERNN-LSTM%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">1、Transformer相比于RNN&#x2F;LSTM，有什么优势？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Transformer%E5%8F%AF%E4%BB%A5%E4%BB%A3%E6%9B%BFseq2seq%EF%BC%9F"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">2、为什么说Transformer可以代替seq2seq？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/22/Transformer%E8%AF%A6%E8%A7%A3/" title="无题">无题</a><time datetime="2024-02-22T09:22:19.782Z" title="发表于 2024-02-22 17:22:19">2024-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/20/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%EF%BC%88Self-Attention%20Mechanism%EF%BC%89/" title="无题">无题</a><time datetime="2024-02-20T02:56:53.768Z" title="发表于 2024-02-20 10:56:53">2024-02-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 雨崽</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="/js/universe.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>